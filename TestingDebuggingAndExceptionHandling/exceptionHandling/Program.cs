// Runtime errors in a C# application are managed using a mechanism called 'exceptions'.
// Exceptions provide a structured, uniform, and type-safe way of handling both system level and application-level error conditions.
// Exceptions are generated by the .NET runtime or by the code in an application

//                                  Common Scenarios That Require Exception Handling

        // User Input: Exceptions can occur when code processes user input
        //                    Example: When the input value is in the wrong format or out of range

        // Data Processing & Computations: Exceptions can occur when code performs data calculations or conversions
        //                    Example: When code attempts to divide by zero, cast to an unsupported type, or assign a value that's out of range

        // File input/output operations: Exceptions can occur when code reads from or writes to a file
        //                                      Example: When the input value is in the wrong format
        //                    Example: When the file doesn't exist, the program doesn't have permission to access the file, or the file is in use by another process

        // Database Operations: Exceptions can occur when code interacts with a database
        //                    Example: When the database connection is lost, a syntax error occurs in a SQL statement, or a constraint violation occurs

        // Network Communication: Exceptions can occur when code communicates over a network
        //                    Example: When the network connection is lost, a timeout occurs, or the remote server returns an error

        // Other External Resources: Exceptions can occur when code communicates with other external resources; i.e. Web Services, REST APIs, or third party libraries
        //                    Example:  Due to network connection issues, malformed data, etc.

        // ** 'throw' is another keyword used to generate an exception object - we'll cover that later

try
{
    // try code block - code that may generate an exception
    // Contains guarded code that may cause an exception. If the code within a try-block causes an exception, the exception is handled by a corresponding catch-block
}
catch
{
    // catch code block - code to handle an exception
    // Contains the code that's executed when a exception is caught. The catch-block can handle the exception, log it, or ignore it.
    // A catch-block can be configured to execute when any exception type occurs, or only when a specific type of exception occurs.
}
finally
{
    // finally code block - code to clean up resources
    // Contains code that executes whether an exception occurs or not.
    // Often used to clean up any resources that are allocated in a try-block.

    // Example: Ensuring that a variable has the correct or required value assigned to it
}

//                                      General Implementation Practices

// The try-catch pattern: Consists of a try-block followed by one or more catch clauses. Each catch-block is used to specify handlers for different exceptions.
// The try-finally pattern: Consists of a try-block followed by a finally-block; Typically, the statements of a finally-block run when control leaves a try statement.
// The try-catch-finally pattern: A common scenario for this pattern is when resources are obtained and used ina try-block, exceptional circumstances are managed in a
//catch-block, and the resources are released or otherwise managed in the finally bock.

//                                      How are exceptions represented in code?

//  Exceptions are represented in code as objects - which means they're an instance of a class!
//  The .NET class library provides exception classes that're accessed in code just like other .NET classes.
//  More precisely, exceptions are types, represented by classes that are all ultimately derived from System.Exception.
//  An exception class that's derived from Exception includes info that identifies the type of exception and contains properties that provide details about the exception.

//                                      Exception Handling Process

// When an exception occurs, the .NET runtime searches for the nearest catch clause that can handle the exception
// The process begins with the method that caused the exception to be throw. 
//      First: The method is examined to see whether the code that caused the exception is inside a try code block.
        // If the code is inside the try code block, the catch clauses associated with the try statement are considered, in order.
        // If the catch clauses are unable to handle the exception, the method that called the current method is searched.
            // This method is examined to determine whether the method call (to the first method) is inside a try code block.
            // If the call is inside a try code block, the associated catch clauses are considered
            
            // This search process continues until a catch clause is found that can handle the current exception
            // Once a catch clause is found that can handle the exception, the runtime prepares to transfer control to the first statement of the catch block.
            // However, before execution of the catch block begins, the runtime executes any finally locks associated with try statements found during the search.
                // If more than one finally block is found, they are executed in order, stating with the one closes to the code that caused the exception to be thrown.
        
        // If NO catch clauses is found to handle the exception, the runtime terminates the application and displays an error message to the user.

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// try-finally nested within a try-catch pattern:

try
{
    // Step 1: code execution begins
    try
    {
        // Step 2: an exception occurs here
    }
    finally
    {
        // Step 4: the system executes the finally code block associated with the try statement when the exception occurred
    }
}
catch   // Step 3: the system finds a catch clauses that can handle the exception
{
    // Step 5; the system transfers control to the first line of the catch code block
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------

//                              Compiler-Generated Exceptions

// The .NET runtime throws exceptions when basic operations fail. Here's a shortlist of runtime exceptions and their error conditions

//          ArrayTypeMismatchException:
                // Thrown when an array can't store a given element because the actual type of the element is incompatible with the actual type of the array.
        string[] names = { "Dog", "Cat", "Fish" };
        Object[] objs = (Object[])names;

        Object obj = (Object)13;
        obj[2] = obj; // ArrayTypeMismatchException occurs
            
//          DivideByZeroException:
                // Thrown when an attempt is made to divide an integral or decimal number value by zero.
        int number1 = 3000;
        int number2 = 0;
        Console.WriteLine(number1 / number2); // DivideByZeroException occurs

//          FormatException:
                // Thrown when the format of an argument is invalid, or when a composite format string is not well formed.
        int valueEntered;
        string userValue = "two";
        valueEntered = int.Parse(userValue); // FormatException occurs
            
//          IndexOutOfRangException:
                // Thrown when an attempt is made to index an array when the index is less than zero or outside the bounds of the array.
        int[] values1 = { 3, 6, 9, 12, 15, 18, 21 };
        int[] values2 = new int[6];

        values2[values1.Length - 1] = values1[values1.Length - 1]; // IndexOutOfRangeException occurs

//          InvalidCastException:
                // Thrown when an explicit conversion from a base type ot an interface or to a derived type fails at runtime.
        object obj2 = "This is a string";
        int num = (int)obj2;

//          NullReferenceException:
                // Thrown when an attempt is made to reference an object whose value is null.
        string? lowCaseString = null;
        Console.WriteLine(lowCaseString.ToUpper());
            
//          OverflowException:
                // Thrown when an arithmetic operation in a checked context overflows.
        decimal x = 400;
        byte i;

        i = (byte)x; // OverflowException occurs
        Console.WriteLine(i);